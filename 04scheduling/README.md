# 04. Scheduling 调度

- 进程行为
 - `CPU`密集型: 大多数时间花费在计算上
 - `I/O`密集型: 大多数时间用于等待`I/O`

- 调度算法分类
 - \*按处理时钟中断方式: **非抢占式**调度算法和**抢占式**调度算法。前者执行一个进程直至其主动释放`CPU`或执行完毕或被阻塞(`I/O`阻塞或者被其它进程阻塞)，后者在一个进程运行了某个设定的固定时段的最大值后，如果还在运行，则挂起之，挑选另一个进程来运行
 - **运行环境分类**
 	- 批处理: 如处理账户收入/账目支出，(银行)利息计算，不存在用户在终端上等待短请求的情形，非抢占式或者固定时段最大值较大的抢占式算法均可满足
	- 交互式: 如服务器(更具体地，如*web*服务器)，要避免一个进程霸占`CPU`拒绝为其它进程服务的情况，或者一个进程出错而无限期地排斥其它进程，需要抢占式的调度算法
	- 实时: 如多媒体系统，一般需要抢占式，但鉴于进程应该了解到它们可能长时间得不到运行(如若如此,**实时**将得不到保障)，一般会较快地完成需要的工作，此时非抢占式也可适用
 - 进程调度算法的目标
 
 | **所有系统** |  |
 |:--------:|:-------------:|
 | Fairness,公平 | 给每个进程公平的CPU份额 |
 | Policy enforcement, 策略强制执行 | 保证每次策略选择都能有效实施 |
 | Blance， 均衡 | 保持系统的各部分都处于忙碌状态(避免如I/O常忙而CPU总在等待/阻塞的情况 |
 | **批处理系统** |  |
 | 吞吐量 | 每小时最大作业数 |
 | 周转时间 | 从提交到终止间的最小间隔时间 |
 | CPU利用率 | 保持CPU始终忙碌 |
 | **交互式系统** |  |
 | 响应时间 | 快速响应请求 |
 | 均衡性 | 满足用户的期望 |
 | **实时系统** |  |
 | 满足截止时间 | 避免丢失数据? |
 | 可预测性 | 在多媒体系统中避免品质降低? |

- 批处理系统的调度算法(一般为非抢占式算法)
 - 先来先服务(*FCFS*, *first-come first-serve*)算法: 按照请求`CPU`的顺序使用`CPU`
 	- 优点: 简单，易于理解，便于在程序中应用
	- 缺点: 当计算密集型和一堆`I/O`密集型进程一起工作，计算密集型进程极易处于长期等待`CPU`资源的过程，并且其他`I/O`密集型进程也"用不上"那么"充足"的`CPU`资源，因为它们自己大多时候都在`I/O`阻塞当中~
 - 最短作业优先(*short job first*)算法: 当进程的作业时间可预知时，需要作业时间最短的进程优先使用`CPU`，这样平均周转时间最短，基于简单的贪心思想
 	- 优点: 可以使得总平均周转时间最短
	- 缺点: 一般只有在所有作业都可同时运行时有效。试想，一个需要较长`CPU`时间的进程更早到达，此时没有其他选择，只能执行之，一个单位时间后，大量只需要很短`CPU`时间的进程到达，但它们此时无法被调度，此时无法得到上述的最短平均周转时间
 - 最短剩余时间优先(*shortest remaining time next*)算法: 最短作业优先的抢占式版本，调度程序总是选择剩余时间最短的进程运行
 - 高回复率优先(*high response-radio first*)算法: ?
 - 几个重要的值:
 	- 到达时间(点), 结束时间(点)
	- 等待时间(段), 执行时间(段)
	- 周转(*turnaround*)时间=等待时间+执行时间=结束时间-到达时间
	- 周转时间占比(*weighting turnaround time*)=周转时间/执行时间(和*response radio*yiyang ?)
	- 回复率(*response radio*)=周转时间/执行时间=1+等待时间/执行时间

- 交互式系统中的调度
 - 轮转调度(*round robin*): 每个进程被分配一个时间段(称为**时间片**,*quantum*), 如果该进程在时间片结束时还在运行，则挂起，在时间片结束前就运行完毕，则`CPU`立即切换
 	- 维护一张"可运行进程"表, 当一个进程用完其时间片，则移到队列末尾
	- 进程切换(上下文切换)需要时间，时间片设得太短会导致过多的进程切换，进程切换时间占比会加大，时间浪费增多; 时间片设得太长，则短的交互请求的响应时间将变长。一般设置时间片长度为`20ms~50ms`
 - 优先级调度: 每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行
 	- 轮转调度认为所有进程同等重要
	- 为了防止高优先级进程无休止地运行，可以在每个时钟中断时降低当前进程的优先级，如果降低后优先级低于其他某个进程，则切换进程运行  =>  `nice`命令
 - 多级队列(*Compatible TimeSharing System*, *CTSS*): 设立优先级类，属于最高优先级类的进程运行`1`个时间片，此高级`2`个时间片，再次者`4`个时间片，以此类推。当一个进程用完分配的时间片后，被移入下一优先级类。
 - 最短进程优先: 类似最短作业优先
 	- 一种策略: 假设估计上一次运行时间`T0`,下一次预计为`T1`，计算`aT0+(1-a)T1`对两个时间加权，依次计入`T2`, `T3`, ...
 	- `T0`, `aT0+(1-a)T1`, `a^2T0+a(1-a)T1+(1-a)T2`, ...
 	- 可以发现，若干次后，`T0`的占比越来越小，称为*老化*(*aging*)。特别地，`a=1/2`时可以通过移位运算(可加速算法常数)
 - 保证调度: 向用户保证其获得的性能, 记录进程自创建以来获得的`CPU`时间，然后根据占用比率比保证的大/小来调整
 - 彩票调度: (= =)发彩票，抽中谁让谁上= =...

- 

- `网游到最后就是。守着一个尸体帮。守着一排永远不会再亮的好友列表。守着他们说好的，等这段时间过去，闲下来马上回来继续陪你掉节操秀下限。突然，回望这几年的江湖路。那些来来去去的人都已不在。那些你爱过恨过的人已变成过往。如斯寂寞。把号停在你一个有特殊意义的地方，然后离开。义无反顾。`
